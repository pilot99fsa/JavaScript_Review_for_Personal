// 分割代入
// let { a, b } = object;
// オブジェクトから特定のプロパティを抽出して宣言を行う。
// 分割代入は、オブジェクトからプロパティを取り出す機能である。


/////////////////////////////

const c = {
    prop: 0
}

let { prop } = c
prop = 1
console.log(c, prop)

//上記のコードをコンソールで確認すると、objectのprop(8行目)は０のままだが、12行目のpropは1となっている
// {prop: 0} 0 index.js:13

//
/////////////////////////////////////////////////
//

//関数と絡めた分割代入と参照の話

function fn(obj) {
    let { prop } = obj;
    prop = 1
    console.log(obj, prop)
}
fn(c)

// これも同じく、コンソールには{prop: 0} 0 index.js:27と表示される

//
//////////////////////////////////////
//

// 関数内で特定のプロパティを使用したい場合はもう少し簡略化できる

function fn({ prop }) { // ()の引数の箇所にオブジェクトを渡してやる。このように書くとこの時点で分割代入が展開されてpropという変数が使用できる
    // let { prop } = obj; この行は不要となる
    prop = 1
    console.log(c, prop) // objは不要なので変数cに変える
}
fn(c)

// これもまた同じく、コンソールには{prop: 0} 0 index.js:41と表示される

//
//////////////////////////////////////////////////
//

// 分割代入は、プロパティ名と同じ名前で変数を定義するときに、プロパティ名を2度書かないで済むのがひとつの利点である。
// オブジェクトを取る引数で分割代入で特定のプロパティのみを使用するというのは頻繁に行われる。


//
///////////////////////////////////////////////////////
//

const f = {
    prop3: {
        prop4: 0
    }
}

let { prop3 } = f;

prop3.prop4 = 1;

console.log(f, prop3)

// コンソールで確認すると、63~64行目のprop3の中身のprop4の値も1に書き換えられている
// 68行目でfからprop3を抽出した時点で、このprop3(68行目)に63~64行目に書いてある、prop4への参照も含まれている
// だから、70行目でprop4の値を変更すると先に書いた、63~64行目のprop3の中身のprop4の値も1に書き換えられてしまうのである

// このように分割代入を使って宣言した変数がオブジェクトである場合、オブジェクトへの参照を保持しているため、分割代入元のオブジェクトにも影響が出る

//　以下はQ&Aに書いてあったコード
// const a = {
//     prop: 0
// }

// let { prop } = a;

// prop = 1; //☆

// function fn(obj) {
//     let { prop } = obj;

//     console.log(a, prop);
// }

// fn(a); 