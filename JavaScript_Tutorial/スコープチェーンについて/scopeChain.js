//スコープチェーンについて
let a = 2;
function fn1() {
    let a = 1;
    function fn2() {
        let a = 3;
        console.log(a)
    }
    fn2()
}
fn1();

//よく見ると変数aが３回宣言されている
//この状態で開発者ツールでaの値を確認すると、3と表示されている
//次にfn2の関数スコープ内で宣言されている変数aを消す(もしくはコメントアウト)と、1と表示されている
//これはfn2の外部スコープであるfn1の関数スコープ内で宣言されている変数aを参照している。
//先ほどと同じく、fn2の関数スコープ内で宣言された変数aを消すと、2と表示される
//これも先ほどと同じく、fn2の最も外側に位置する外部スコープであるグローバルスコープで宣言された変数aを参照している
//このように、スコープが複数階層に連なっている場合は、一番内側のスコープから変数を探して参照する。
//各階層に同じ変数名が存在する場合は、最も内側のスコープ内の変数を参照する
//つまり内側から外側の順序で変数を探すのである。これがスコープチェーンによって発生する変数の獲得帰順である
//

//
//グローバルスコープとスクリプトスコープに同じ変数名が存在する場合ついて
let c = 2;
window.c = 4;
//cが二つ存在する。この場合、fn4の関数スコープ内で実行されたconsole.log(c)はどちらを取得するだろうか？
function fn3() {
    // let c = 1;
    function fn4() {
        // let c = 3;
        console.log(c)
    }
    fn4()
}
fn3();

//開発者ツールで確認すると、2と表示される。つまりletで宣言した変数cが取得されている
//このことから、グローバルスコープはスクリプトスコープよりも外側のスコープであることが分かる
//もちろんletで宣言された変数cがなければ(あるいはコメントアウトすると)、開発者ツールには4と表示される

//まとめると、JavaScriptにおいては各階層のスコープに名前が重複している変数が存在している場合、内側のスコープから順に探して最終的にグローバルスコープにもなければエラーとなる
//

//
//よくありがちなミス、ダメなコーディング

let d = 2;
window.d = 4;
function fn5() {
    let d = 1;
    function fn6() {
        console.log(d)
        //let d = 3; letで宣言する前にconsole.logで変数dを取得しようとしているが、エラーが発生する

        if (true) {
            var d = 5;
        } //これはブロックスコープが生成されないため、外部スコープの値を取得しているつもりが、ホイスティングが起こってundefinedと表示される。これはエラーが起きないので要注意である
    }
    fn6()
}
fn5();