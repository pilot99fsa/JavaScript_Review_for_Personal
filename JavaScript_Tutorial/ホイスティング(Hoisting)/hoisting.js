//ホイスティング(巻き上げ)とは. コンテキスト内で宣言した変数や関数の定義をコード実行前にメモリに配置すること。
//別の言い方をすると、変数宣言が常に関数の先頭で行われたことにされる挙動のことをホイスティングと言います。
//「宣言の捲き上げ」とも呼ぶ
function a() {
    console.log("a is called")
}
a();

////////////////////////////////////

b();

function b() {
    console.log("b is called")
}

//どちらの関数の実行結果もブラウザのコンソールで確認することができる
//bの関数の実行より後に、bの関数が宣言がされているが、これは定義がメモリ上に配置されているために問題なくコンソールで確認できる
//

//
//ホイスティング、変数宣言の方法による違いについて

//通常のfunction宣言文
c();

function c() {
    console.log(" is called")
} //問題なく実行できる、コンソール上に表示される

/////////////////////////////////////
//

//varで宣言した場合
console.log(d);

var d = 0; //これではブラウザのコンソール上で確認するとundefined(未定義)と表示される
//この形では、コンソールログを読んだ時点ではdに値は設定されていない状況になる
//var d;
//console.log(d);
//d = 0;
//このような事が起こっていると想像すれば良い
//なので　console.log(d); を再度実行するとコンソールログに0と表示される

//
var e; //この時点ではまず変数のメモリスペースを確保をしただけなので、何も表示されない(未定義である) 
console.log(d); //当然console.logを実行してもundefinedと表示される
e = 0; //ここでeに値を代入する
console.log(d); //これでやっとコンソール上にdに代入した値が表示される
//
//わざわざこんな冗長な書き方をしているが、現場では必ずしもこんな書き方をする必要ない
//関数の定義前に関数を呼び出しても実行できるという事実があるだけで、それ以上の意味はない。
//要は、「定義前に呼んでも問題ない」という事実だけわかっていれば問題ない。
//

//
//letで宣言した場合

//console.log(f);

//let f = 0;
//varと同じように変数のメモリスペースの確保は行われるがletの場合はJSエンジンによるundefinedの初期化が行われないため、エラーが表示される
//constで宣言した場合も同じである
//

//
//その他にも、varと,let/constでは挙動に差があるのでvarの使用は非推奨である(よっぽどの理由がなければ使わない)
//

//
//ホイスティングは、コンテキストが生成された瞬間に起こる
//グローバルコンテキストが宣言された時点でメモリスペースの確保がなされる
//

//関数の宣言方法
function g() { //functionから始まり、関数名() {}で書く形
    console.log("I am g")
}
g();
//この書き方を関数宣言と呼ぶ
//

//
const h = function () { // letもしくはconst (関数名) = function() {} 無名関数を代入する
    console.log("I am h")
}
h();
//この書き方を関数式と呼ぶ
//

//
//関数宣言では、宣言より前で関数を実行できる
//関数式では宣言した後でなければ、関数が実行できない(文法エラーとなる)
//関数宣言と関数式では、Functionオブジェクトの生成されるタイミングが異なる。それによるパフォーマンスの違いを通常は気にする必要はないが、覚えておいた方がよいだろう。普段の実用面では、関数の定義よりも手前で呼び出せるかどうかという違いになる。
//

//個人ログ:普段から関数を宣言→関数の実行、の順番で書いていればそれほど気にすることはない